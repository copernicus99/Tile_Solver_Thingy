<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tile Solver Selection</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="overlay" id="run-overlay" aria-hidden="true">
        <div class="panel" role="dialog" aria-live="polite">
            <div class="overlay-header">
                <div class="spinner" id="overlay-spinner"></div>
                <div>
                    <h2 id="overlay-title">Running tile solver...</h2>
                    <p id="overlay-subtitle">Preparing phases and estimating time requirements.</p>
                </div>
            </div>
            <dl class="overlay-stats">
                <div class="full-row">
                    <dt>Status</dt>
                    <dd id="stat-status">Initializing…</dd>
                </div>
                <div>
                    <dt>Phase</dt>
                    <dd id="stat-phase">—</dd>
                </div>
                <div>
                    <dt>Phase Quota</dt>
                    <dd id="stat-phase-allotment">—</dd>
                </div>
                <div>
                    <dt>Attempt</dt>
                    <dd id="stat-attempt">—</dd>
                </div>
                <div>
                    <dt>Evaluating Grid</dt>
                    <dd id="stat-grid">—</dd>
                </div>
                <div class="full-row">
                    <dt>Total Quota</dt>
                    <dd id="stat-total-quota">—</dd>
                </div>
                <div class="full-row">
                    <dt>Total Elapsed Time</dt>
                    <dd id="stat-elapsed">0s</dd>
                </div>
            </dl>
            <div class="progress-section">
                <div class="progress-row">
                    <span class="progress-label">Phase</span>
                    <svg class="progress-svg" viewBox="0 0 100 8" role="img" aria-labelledby="phase-progress-label phase-progress-title">
                        <title id="phase-progress-title">Current phase progress</title>
                        <defs>
                            <linearGradient id="phase-progress-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" stop-color="#4ecdc4"></stop>
                                <stop offset="100%" stop-color="#65e2d9"></stop>
                            </linearGradient>
                        </defs>
                        <rect class="progress-track" x="0" y="0" width="100" height="8" rx="4" ry="4"></rect>
                        <rect class="progress-fill" id="phase-progress" x="0" y="0" width="100" height="8" rx="4" ry="4" fill="url(#phase-progress-gradient)" style="--progress:0;"></rect>
                    </svg>
                    <span id="phase-progress-label" class="progress-value">0%</span>
                </div>
                <div class="progress-row">
                    <span class="progress-label">Overall</span>
                    <svg class="progress-svg" viewBox="0 0 100 8" role="img" aria-labelledby="overall-progress-label overall-progress-title">
                        <title id="overall-progress-title">Overall solver progress</title>
                        <defs>
                            <linearGradient id="overall-progress-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" stop-color="#4ecdc4"></stop>
                                <stop offset="100%" stop-color="#65e2d9"></stop>
                            </linearGradient>
                        </defs>
                        <rect class="progress-track" x="0" y="0" width="100" height="8" rx="4" ry="4"></rect>
                        <rect class="progress-fill" id="overall-progress" x="0" y="0" width="100" height="8" rx="4" ry="4" fill="url(#overall-progress-gradient)" style="--progress:0;"></rect>
                    </svg>
                    <span id="overall-progress-label" class="progress-value">0%</span>
                </div>
            </div>
            <div class="overlay-footer">
                <button type="button" id="overlay-hide" class="link-button" hidden>Hide</button>
                <button type="button" id="overlay-abort" class="link-button" disabled>Abort</button>
            </div>
        </div>
    </div>
    <main>
        <header>
            <h1>Tile Layout Solver</h1>
            <p class="subtitle">Select tile sizes and quantities to generate an optimum layout.</p>
        </header>
        <form action="{{ url_for('solve_tiles') }}" method="post" id="tile-form">
            <div class="form-status" aria-hidden="false">
                <div class="status-indicator" id="perfect-square-indicator" role="status" aria-live="polite">
                    <span class="status-icon" aria-hidden="true"></span>
                    <div class="status-copy">
                        <span class="status-title">Perfect Square</span>
                        <span class="status-description" id="perfect-square-description">Select tiles to build a square.</span>
                    </div>
                </div>
            </div>
            <div class="tiles-grid">
                {% for name, dims in tile_options.items() %}
                <div class="tile-card">
                    <label for="{{ name }}">{{ name.replace('x', ' ft × ') }} ft tile</label>
                    <select name="{{ name }}" id="{{ name }}" data-width-ft="{{ '%.3f'|format(dims[0]) }}" data-height-ft="{{ '%.3f'|format(dims[1]) }}">
                        {% for i in range(0, max_quantity + 1) %}
                        <option value="{{ i }}">{{ i }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endfor %}
            </div>
            <div style="text-align:center;">
                <button type="submit">Run Tile</button>
            </div>
        </form>
    </main>
    <script>
        const form = document.getElementById('tile-form');
        const gridUnitFt = {{ grid_unit | tojson }};
        const unitAreaFt2 = gridUnitFt * gridUnitFt;
        const tileSelects = Array.from(document.querySelectorAll('.tile-card select'));
        const perfectSquareIndicator = document.getElementById('perfect-square-indicator');
        const perfectSquareDescription = document.getElementById('perfect-square-description');

        function updatePerfectSquareIndicator() {
            let totalArea = 0;
            tileSelects.forEach((select) => {
                const quantity = Number(select.value);
                if (!Number.isFinite(quantity) || quantity <= 0) {
                    return;
                }
                const width = Number(select.dataset.widthFt);
                const height = Number(select.dataset.heightFt);
                if (!Number.isFinite(width) || !Number.isFinite(height)) {
                    return;
                }
                totalArea += quantity * width * height;
            });

            let description = 'Select tiles to build a square.';
            let isPerfectSquare = false;

            if (totalArea > 0 && Number.isFinite(unitAreaFt2) && unitAreaFt2 > 0) {
                const cellsExact = totalArea / unitAreaFt2;
                const cellsRounded = Math.round(cellsExact);
                const alignedToGrid = Math.abs(cellsExact - cellsRounded) < 1e-6;
                if (!alignedToGrid) {
                    description = `${totalArea.toFixed(2)} ft² (needs grid alignment)`;
                } else {
                    const root = Math.round(Math.sqrt(cellsRounded));
                    if (root * root === cellsRounded) {
                        const sideFt = root * gridUnitFt;
                        description = `${sideFt.toFixed(1)} ft × ${sideFt.toFixed(1)} ft ready`;
                        isPerfectSquare = true;
                    } else {
                        description = `${totalArea.toFixed(2)} ft² (not a perfect square)`;
                    }
                }
            }

            if (perfectSquareIndicator) {
                perfectSquareIndicator.classList.toggle('active', isPerfectSquare);
                perfectSquareIndicator.setAttribute('data-status', isPerfectSquare ? 'ready' : 'inactive');
            }
            if (perfectSquareDescription) {
                perfectSquareDescription.textContent = description;
            }
        }

        updatePerfectSquareIndicator();
        form.addEventListener('change', updatePerfectSquareIndicator);

        const overlay = document.getElementById('run-overlay');
        const statusText = document.getElementById('stat-status');
        const phaseText = document.getElementById('stat-phase');
        const phaseAllotmentText = document.getElementById('stat-phase-allotment');
        const attemptText = document.getElementById('stat-attempt');
        const gridText = document.getElementById('stat-grid');
        const elapsedText = document.getElementById('stat-elapsed');
        const totalQuotaText = document.getElementById('stat-total-quota');
        const overallProgressBar = document.getElementById('overall-progress');
        const phaseProgressBar = document.getElementById('phase-progress');
        const overallProgressLabel = document.getElementById('overall-progress-label');
        const phaseProgressLabel = document.getElementById('phase-progress-label');
        const overlaySubtitle = document.getElementById('overlay-subtitle');
        const overlayTitle = document.getElementById('overlay-title');

        let currentEventSource = null;
        let currentRunId = null;
        function resetOverlay() {
            statusText.textContent = 'Initializing…';
            phaseText.textContent = '—';
            phaseAllotmentText.textContent = '—';
            attemptText.textContent = '—';
            gridText.textContent = '—';
            totalQuotaText.textContent = '—';
            elapsedText.textContent = '0s';
            updateProgress(overallProgressBar, overallProgressLabel, 0);
            updateProgress(phaseProgressBar, phaseProgressLabel, 0);
            overlaySubtitle.textContent = 'Preparing phases and estimating time requirements.';
            overlayTitle.textContent = 'Running tile solver...';
            overlay.classList.remove('error');
            overlay.setAttribute('aria-hidden', 'false');
            overlay.classList.add('active');
        }

        function updateProgress(bar, label, value) {
            if (!bar) {
                return;
            }
            const clamped = Math.max(0, Math.min(100, value));
            bar.style.setProperty('--progress', (clamped / 100).toFixed(4));
            bar.setAttribute('data-progress', clamped.toFixed(1));
            if (label) {
                label.textContent = `${clamped.toFixed(1)}%`;
            }
        }

        function formatSeconds(seconds) {
            if (!seconds || seconds < 0) {
                return '0s';
            }
            const rounded = Math.round(seconds);
            const minutes = Math.floor(rounded / 60);
            const secs = rounded % 60;
            if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            }
            if (secs > 0) {
                return `${secs}s`;
            }
            return '0s';
        }

        function formatIntegerWithSeparators(value) {
            if (typeof value !== 'number' || !Number.isFinite(value)) {
                return value;
            }
            return value.toLocaleString();
        }

        function buildAttemptDisplay({
            boardLabel,
            variantLabel,
            attemptIndex,
            totalAttempts,
            timeLimitSec,
            attemptElapsed,
            backtracks,
        }) {
            const lines = [];
            const hasAttemptIndex = typeof attemptIndex === 'number' && attemptIndex > 0;
            if (hasAttemptIndex) {
                const attemptCount = typeof totalAttempts === 'number'
                    ? `Attempt ${attemptIndex} of ${totalAttempts}`
                    : `Attempt ${attemptIndex}`;
                lines.push(attemptCount);
            }

            const parsedTimeLimit = Number(timeLimitSec);
            const hasTimeLimit = Number.isFinite(parsedTimeLimit);
            const parsedElapsed = Number(attemptElapsed);
            const hasElapsed = Number.isFinite(parsedElapsed);
            if (hasTimeLimit && hasElapsed) {
                lines.push(`Quota ${formatSeconds(parsedTimeLimit)}`);
            } else if (hasElapsed) {
                lines.push(`Elapsed ${formatSeconds(parsedElapsed)}`);
            } else if (hasTimeLimit) {
                lines.push(`Quota ${formatSeconds(parsedTimeLimit)}`);
            }

            const parsedBacktracks = Number(backtracks);
            if (Number.isFinite(parsedBacktracks)) {
                lines.push(`Backtracks ${formatIntegerWithSeparators(parsedBacktracks)}`);
            }

            return lines.join('\n');
        }

        function formatBoardSize(size) {
            if (!Array.isArray(size) || size.length < 2) {
                return '—';
            }
            return `${size[0].toFixed(1)} ft × ${size[1].toFixed(1)} ft`;
        }

        function updateGridDisplay(boardLabel, variantLabel) {
            if (!gridText) {
                return;
            }
            if (!boardLabel || boardLabel === '—') {
                gridText.textContent = '—';
                return;
            }
            if (variantLabel) {
                gridText.innerHTML = `${boardLabel}<br><span class="grid-variant">${variantLabel}</span>`;
            } else {
                gridText.textContent = boardLabel;
            }
        }

        function closeEventSource() {
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }
        }

        function handleEvent(data) {
            if (!data) return;
            switch (data.type) {
                case 'run_started':
                    overlaySubtitle.textContent = 'Preparing phases and estimating time requirements.';
                    totalQuotaText.textContent = formatSeconds(data.total_allotment);
                    statusText.textContent = 'Solving…';
                    break;
                case 'phase_started':
                    statusText.textContent = `Solving ${data.phase}`;
                    phaseText.textContent = `${data.phase} (${(data.phase_index + 1)} of ${data.phase_count})`;
                    phaseAllotmentText.textContent = data.time_limit_sec
                        ? `${formatSeconds(data.time_limit_sec)}`
                        : 'No limit';
                    attemptText.textContent = '—';
                    gridText.textContent = '—';
                    updateProgress(phaseProgressBar, phaseProgressLabel, 0);
                    break;
                case 'attempt_started':
                    const boardLabel = formatBoardSize(data.board_size_ft);
                    updateGridDisplay(boardLabel, data.variant_label);
                    attemptText.textContent = buildAttemptDisplay({
                        boardLabel,
                        variantLabel: data.variant_label,
                        attemptIndex: data.attempt_index,
                        totalAttempts: data.total_attempts,
                        timeLimitSec: data.time_limit_sec,
                        attemptElapsed: data.attempt_elapsed,
                        backtracks: data.backtracks,
                    });
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    updateProgress(phaseProgressBar, phaseProgressLabel, (data.phase_progress || 0) * 100);
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    break;
                case 'attempt_completed':
                    if (Array.isArray(data.board_size_ft)) {
                        const boardLabelCompleted = formatBoardSize(data.board_size_ft);
                        updateGridDisplay(boardLabelCompleted, data.variant_label);
                        attemptText.textContent = buildAttemptDisplay({
                            boardLabel: boardLabelCompleted,
                            variantLabel: data.variant_label,
                            attemptIndex: data.attempt_index,
                            totalAttempts: data.total_attempts,
                            timeLimitSec: data.time_limit_sec,
                            attemptElapsed: data.attempt_elapsed,
                            backtracks: data.backtracks,
                        });
                    }
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    updateProgress(phaseProgressBar, phaseProgressLabel, (data.phase_progress || 0) * 100);
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    statusText.textContent = data.success ? 'Layout found!' : 'Exploring layouts…';
                    break;
                case 'attempt_progress':
                    statusText.textContent = 'Exploring layouts…';
                    if (Array.isArray(data.board_size_ft)) {
                        const boardLabel = formatBoardSize(data.board_size_ft);
                        updateGridDisplay(boardLabel, data.variant_label);
                        attemptText.textContent = buildAttemptDisplay({
                            boardLabel,
                            variantLabel: data.variant_label,
                            attemptIndex: data.attempt_index,
                            totalAttempts: data.total_attempts,
                            timeLimitSec: data.time_limit_sec,
                            attemptElapsed: data.attempt_elapsed,
                            backtracks: data.backtracks,
                        });
                    }
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    updateProgress(phaseProgressBar, phaseProgressLabel, (data.phase_progress || 0) * 100);
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    break;
                case 'phase_completed':
                    statusText.textContent = data.success ? `${data.phase} complete` : `${data.phase} exhausted`;
                    updateProgress(phaseProgressBar, phaseProgressLabel, 100);
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    break;
                case 'run_completed':
                    overlaySubtitle.textContent = data.success
                        ? 'Solver finished. Preparing results…'
                        : 'No solution found within the time quota.';
                    statusText.textContent = data.success ? 'Solver finished' : 'Solver complete (no solution)';
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    break;
                case 'error':
                    statusText.textContent = 'Unable to start solver';
                    overlaySubtitle.textContent = data.message || 'An unexpected error occurred.';
                    updateProgress(overallProgressBar, overallProgressLabel, 0);
                    updateProgress(phaseProgressBar, phaseProgressLabel, 0);
                    break;
                case 'finished':
                    closeEventSource();
                    if (data.success) {
                        window.location.href = `/runs/${data.run_id}/result`;
                    } else if (data.error) {
                        overlay.classList.add('error');
                        overlayTitle.textContent = 'Solver error';
                        overlaySubtitle.textContent = data.error;
                        overlay.setAttribute('aria-hidden', 'false');
                    } else {
                        window.location.href = `/runs/${data.run_id}/result`;
                    }
                    break;
                default:
                    break;
            }
        }

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            resetOverlay();
            closeEventSource();
            currentRunId = null;
            const formData = new FormData(form);
            try {
                const response = await fetch('{{ url_for('start_run') }}', {
                    method: 'POST',
                    body: formData,
                });
                if (!response.ok) {
                    throw new Error('Unable to start solver run.');
                }
                const payload = await response.json();
                currentRunId = payload.run_id;
                currentEventSource = new EventSource(`/runs/${currentRunId}/stream`);
                currentEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleEvent(data);
                    } catch (err) {
                        console.error('Failed to parse progress event', err);
                    }
                };
                currentEventSource.addEventListener('end', () => {
                    closeEventSource();
                });
            } catch (error) {
                console.error(error);
                statusText.textContent = 'Unable to start solver';
                overlaySubtitle.textContent = error.message || 'An unexpected error occurred.';
                overlay.classList.add('error');
            }
        });
    </script>
</body>
</html>
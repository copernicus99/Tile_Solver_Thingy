<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tile Solver Selection</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="overlay" id="run-overlay" aria-hidden="true">
        <div class="panel" role="dialog" aria-live="polite">
            <div class="overlay-header">
                <div class="spinner" id="overlay-spinner"></div>
                <div>
                    <h2 id="overlay-title">Running tile solver...</h2>
                    <p id="overlay-subtitle">Preparing phases and estimating time requirements.</p>
                </div>
            </div>
            <dl class="overlay-stats">
                <div class="full-row">
                    <dt>Status</dt>
                    <dd id="stat-status">Initializing…</dd>
                </div>
                <div>
                    <dt>Phase</dt>
                    <dd id="stat-phase">—</dd>
                </div>
                <div>
                    <dt>Phase Quota</dt>
                    <dd id="stat-phase-allotment">—</dd>
                </div>
                <div>
                    <dt>Attempt</dt>
                    <dd id="stat-attempt">—</dd>
                </div>
                <div>
                    <dt>Evaluating Grid</dt>
                    <dd id="stat-grid">—</dd>
                </div>
                <div class="full-row">
                    <dt>Total Quota</dt>
                    <dd id="stat-total-quota">—</dd>
                </div>
                <div class="full-row">
                    <dt>Total Elapsed Time</dt>
                    <dd id="stat-elapsed">0s</dd>
                </div>
            </dl>
            <div class="progress-section">
                <div class="progress-row">
                    <span class="progress-label">Phase</span>
                    <svg class="progress-svg" viewBox="0 0 100 8" role="img" aria-labelledby="phase-progress-label phase-progress-title">
                        <title id="phase-progress-title">Current phase progress</title>
                        <defs>
                            <linearGradient id="phase-progress-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" stop-color="#4ecdc4"></stop>
                                <stop offset="100%" stop-color="#65e2d9"></stop>
                            </linearGradient>
                        </defs>
                        <rect class="progress-track" x="0" y="0" width="100" height="8" rx="4" ry="4"></rect>
                        <rect class="progress-fill" id="phase-progress" x="0" y="0" width="100" height="8" rx="4" ry="4" fill="url(#phase-progress-gradient)" style="--progress:0;"></rect>
                    </svg>
                    <span id="phase-progress-label" class="progress-value">0%</span>
                </div>
                <div class="progress-row">
                    <span class="progress-label">Overall</span>
                    <svg class="progress-svg" viewBox="0 0 100 8" role="img" aria-labelledby="overall-progress-label overall-progress-title">
                        <title id="overall-progress-title">Overall solver progress</title>
                        <defs>
                            <linearGradient id="overall-progress-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" stop-color="#4ecdc4"></stop>
                                <stop offset="100%" stop-color="#65e2d9"></stop>
                            </linearGradient>
                        </defs>
                        <rect class="progress-track" x="0" y="0" width="100" height="8" rx="4" ry="4"></rect>
                        <rect class="progress-fill" id="overall-progress" x="0" y="0" width="100" height="8" rx="4" ry="4" fill="url(#overall-progress-gradient)" style="--progress:0;"></rect>
                    </svg>
                    <span id="overall-progress-label" class="progress-value">0%</span>
                </div>
            </div>
            <div class="overlay-footer">
                <button type="button" id="overlay-hide" class="link-button" hidden>Hide</button>
                <button type="button" id="overlay-abort" class="link-button" disabled>Abort</button>
            </div>
        </div>
    </div>
    <main>
        <header>
            <h1>Tile Solver Thingy</h1>
            <p class="subtitle">Select tile sizes and quantities to generate an optimum layout.</p>
        </header>
        <form action="{{ url_for('solve_tiles') }}" method="post" id="tile-form">
            <div class="form-status" aria-hidden="false">
                <button type="button" id="open-tilebags" class="status-pill-button">Tile Bags</button>
                <button type="button" id="open-predictor" class="status-pill-button status-pill-button--accent">Predict Solve %</button>
                <div class="status-indicator" id="perfect-square-indicator" role="status" aria-live="polite">
                    <span class="status-icon" aria-hidden="true"></span>
                    <div class="status-copy">
                        <span class="status-title">Perfect Square</span>
                        <span class="status-description" id="perfect-square-description">Select tiles to build a square.</span>
                    </div>
                </div>
            </div>
            <div class="tiles-grid">
                {% for name, dims in tile_options.items() %}
                <div class="tile-card">
                    <label for="{{ name }}">{{ name.replace('x', ' ft × ') }} ft tile</label>
                    <select name="{{ name }}" id="{{ name }}" data-width-ft="{{ '%.3f'|format(dims[0]) }}" data-height-ft="{{ '%.3f'|format(dims[1]) }}">
                        {% for i in range(0, max_quantity + 1) %}
                        <option value="{{ i }}">{{ i }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endfor %}
            </div>
            <div style="text-align:center;">
                <button type="submit">Run Solver</button>
            </div>
        </form>
    </main>
    <div class="tilebag-modal" id="tilebag-modal" hidden>
        <div class="tilebag-modal__backdrop" data-tilebag-close></div>
        <div class="tilebag-modal__panel" role="dialog" aria-modal="true" aria-labelledby="tilebag-modal-title">
            <div class="tilebag-modal__header">
                <h2 id="tilebag-modal-title">Choose a tile bag</h2>
                <button type="button" class="icon-button" data-tilebag-close aria-label="Close tile bag picker">×</button>
            </div>
            <div class="tilebag-modal__body">
                {% if tile_bags %}
                <ul class="tilebag-list">
                    {% for bag in tile_bags %}
                    <li class="tilebag-list__item">
                        <button type="button" class="tilebag-option" data-tilebag="{{ bag.name }}">{{ bag.name }}</button>
                        {% if bag.tiles %}
                        <dl class="tilebag-contents">
                            {% for tile_name, quantity in bag.tiles.items() %}
                            <div>
                                <dt>{{ tile_name.replace('x', ' ft × ') }} ft</dt>
                                <dd>{{ quantity }}</dd>
                            </div>
                            {% endfor %}
                        </dl>
                        {% endif %}
                    </li>
                    {% endfor %}
                </ul>
                {% else %}
                <p class="tilebag-empty">No tile bags defined. Edit <code>tile_bags.json</code> to add some.</p>
                {% endif %}
            </div>
        </div>
    </div>
    <div class="predictor-modal" id="predictor-modal" hidden>
        <div class="predictor-modal__backdrop" data-predictor-close></div>
        <div class="predictor-modal__panel" role="dialog" aria-modal="true" aria-labelledby="predictor-modal-title">
            <div class="predictor-modal__header">
                <h2 id="predictor-modal-title">Solve Probability Predictor</h2>
                <button type="button" class="icon-button" data-predictor-close aria-label="Close predictor panel">×</button>
            </div>
            <div class="predictor-modal__body">
                <div class="predictor-summary">
                    <div class="predictor-score" id="predictor-score" aria-live="polite">--%</div>
                    <div class="predictor-tolerance" id="predictor-tolerance">±--%</div>
                    <div class="predictor-confidence" id="predictor-confidence">Confidence: —</div>
                    <p class="predictor-note" id="predictor-summary">Select tiles and adjust solver switches to see the estimated probability of a successful solve. The prediction reports an estimated percentage with a ± tolerance band.</p>
                </div>
                <section class="predictor-inputs" aria-label="Prediction controls">
                    <div class="predictor-input">
                        <label for="predictor-max-edge-ratio">Max edge ratio</label>
                        <div class="predictor-input-control">
                            <input type="range" min="0.3" max="0.9" step="0.05" id="predictor-max-edge-ratio" data-config-key="max_edge_ratio">
                            <span class="predictor-input-value" data-output-for="predictor-max-edge-ratio">0.60</span>
                        </div>
                    </div>
                    <div class="predictor-input">
                        <label class="checkbox-label">
                            <input type="checkbox" id="predictor-plus-toggle" data-config-key="plus_toggle">
                            Allow plus adjacency
                        </label>
                    </div>
                    <div class="predictor-input">
                        <label for="predictor-same-shape-limit">Same side shape limit</label>
                        <input type="number" min="0" max="6" step="1" id="predictor-same-shape-limit" data-config-key="same_shape_limit">
                    </div>
                    <div class="predictor-input">
                        <label for="predictor-pop-out-depth">Max pop out depth</label>
                        <input type="number" min="0" max="6" step="1" id="predictor-pop-out-depth" data-config-key="max_pop_out_depth">
                    </div>
                    <div class="predictor-input">
                        <label for="predictor-mask-time">Mask validation time limit (sec)</label>
                        <input type="number" min="15" max="600" step="15" id="predictor-mask-time" data-config-key="mask_validation_time_limit">
                    </div>
                    <div class="predictor-input">
                        <label for="predictor-rectangle-aspect">Max rectangle aspect ratio</label>
                        <input type="number" min="1" max="2.5" step="0.1" id="predictor-rectangle-aspect" data-config-key="max_rectangle_aspect_ratio">
                    </div>
                </section>
                <div class="predictor-actions">
                    <button type="button" class="secondary-button" id="predictor-reset">Reset to defaults</button>
                    <button type="button" class="secondary-button predictor-refresh" id="predictor-refresh">Recalculate</button>
                </div>
                <section class="predictor-factors" aria-live="polite" aria-label="Prediction breakdown">
                    <h3>What is influencing the result?</h3>
                    <ul id="predictor-factors-list"></ul>
                </section>
                <section class="predictor-config" aria-label="Effective configuration snapshot">
                    <h3>Effective configuration used</h3>
                    <dl id="predictor-config-list"></dl>
                </section>
                <p class="predictor-footnote">The predictor considers all solver configuration values, including those not directly exposed above. Adjusting tiles or the switches will re-run the estimate.</p>
                <div class="predictor-status" id="predictor-status" role="status" aria-live="polite"></div>
            </div>
        </div>
    </div>
    <script>
        const form = document.getElementById('tile-form');
        const gridUnitFt = {{ grid_unit | tojson }};
        const unitAreaFt2 = gridUnitFt * gridUnitFt;
        const tileSelects = Array.from(document.querySelectorAll('.tile-card select'));
        const maxQuantity = {{ max_quantity | tojson }};
        const tileBags = {{ tile_bags | tojson }};
        const predictorDefaults = {{ predictor_defaults | tojson }};
        const perfectSquareIndicator = document.getElementById('perfect-square-indicator');
        const perfectSquareDescription = document.getElementById('perfect-square-description');

        function updatePerfectSquareIndicator() {
            let totalArea = 0;
            tileSelects.forEach((select) => {
                const quantity = Number(select.value);
                if (!Number.isFinite(quantity) || quantity <= 0) {
                    return;
                }
                const width = Number(select.dataset.widthFt);
                const height = Number(select.dataset.heightFt);
                if (!Number.isFinite(width) || !Number.isFinite(height)) {
                    return;
                }
                totalArea += quantity * width * height;
            });

            let description = 'Select tiles to build a square.';
            let isPerfectSquare = false;

            if (totalArea > 0 && Number.isFinite(unitAreaFt2) && unitAreaFt2 > 0) {
                const cellsExact = totalArea / unitAreaFt2;
                const cellsRounded = Math.round(cellsExact);
                const alignedToGrid = Math.abs(cellsExact - cellsRounded) < 1e-6;
                if (!alignedToGrid) {
                    description = `${totalArea.toFixed(2)} ft² (needs grid alignment)`;
                } else {
                    const root = Math.round(Math.sqrt(cellsRounded));
                    if (root * root === cellsRounded) {
                        const sideFt = root * gridUnitFt;
                        description = `${sideFt.toFixed(1)} ft × ${sideFt.toFixed(1)} ft ready`;
                        isPerfectSquare = true;
                    } else {
                        description = `${totalArea.toFixed(2)} ft² (not a perfect square)`;
                    }
                }
            }

            if (perfectSquareIndicator) {
                perfectSquareIndicator.classList.toggle('active', isPerfectSquare);
                perfectSquareIndicator.setAttribute('data-status', isPerfectSquare ? 'ready' : 'inactive');
            }
            if (perfectSquareDescription) {
                perfectSquareDescription.textContent = description;
            }
        }

        updatePerfectSquareIndicator();
        form.addEventListener('change', updatePerfectSquareIndicator);

        function openTileBagModal() {
            if (!tileBagModal) {
                return;
            }
            tileBagModal.removeAttribute('hidden');
            tileBagModal.setAttribute('aria-hidden', 'false');
        }

        function closeTileBagModal() {
            if (!tileBagModal) {
                return;
            }
            tileBagModal.setAttribute('aria-hidden', 'true');
            tileBagModal.setAttribute('hidden', '');
        }

        function applyTileBag(bagName) {
            const bag = tileBags.find((entry) => entry && entry.name === bagName);
            if (!bag) {
                return;
            }
            const tiles = bag.tiles || {};
            tileSelects.forEach((select) => {
                const quantity = Number(tiles[select.id] ?? 0);
                const clamped = Math.min(Math.max(quantity, 0), maxQuantity);
                select.value = String(clamped);
            });
            updatePerfectSquareIndicator();
            closeTileBagModal();
        }

        const tileBagButton = document.getElementById('open-tilebags');
        const tileBagModal = document.getElementById('tilebag-modal');
        const tileBagCloseButtons = tileBagModal ? tileBagModal.querySelectorAll('[data-tilebag-close]') : [];
        const tileBagOptions = tileBagModal ? tileBagModal.querySelectorAll('[data-tilebag]') : [];

        if (tileBagButton) {
            tileBagButton.addEventListener('click', openTileBagModal);
        }

        tileBagCloseButtons.forEach((button) => {
            button.addEventListener('click', closeTileBagModal);
        });

        tileBagOptions.forEach((button) => {
            button.addEventListener('click', () => {
                const bagName = button.getAttribute('data-tilebag');
                if (bagName) {
                    applyTileBag(bagName);
                }
            });
        });

        if (tileBagModal) {
            tileBagModal.addEventListener('click', (event) => {
                if (event.target === tileBagModal) {
                    closeTileBagModal();
                }
            });
        }

        const predictorModal = document.getElementById('predictor-modal');
        const predictorOpenButton = document.getElementById('open-predictor');
        const predictorCloseButtons = predictorModal ? predictorModal.querySelectorAll('[data-predictor-close]') : [];
        const predictorInputs = predictorModal ? predictorModal.querySelectorAll('[data-config-key]') : [];
        const predictorScore = document.getElementById('predictor-score');
        const predictorTolerance = document.getElementById('predictor-tolerance');
        const predictorConfidence = document.getElementById('predictor-confidence');
        const predictorSummary = document.getElementById('predictor-summary');
        const predictorFactorsList = document.getElementById('predictor-factors-list');
        const predictorConfigList = document.getElementById('predictor-config-list');
        const predictorStatus = document.getElementById('predictor-status');
        const predictorResetButton = document.getElementById('predictor-reset');
        const predictorRefreshButton = document.getElementById('predictor-refresh');
        const predictorEndpoint = '{{ url_for('predict_probability') }}';

        let predictorInitialized = false;
        let predictorRefreshTimeout = null;
        let predictorController = null;

        function isPredictorOpen() {
            return Boolean(predictorModal) && !predictorModal.hasAttribute('hidden');
        }

        function setPredictorStatus(message, variant = 'idle') {
            if (!predictorStatus) {
                return;
            }
            predictorStatus.textContent = message;
            predictorStatus.setAttribute('data-status', variant);
        }

        function openPredictor() {
            if (!predictorModal) {
                return;
            }
            predictorModal.removeAttribute('hidden');
            predictorModal.setAttribute('aria-hidden', 'false');
            if (!predictorInitialized) {
                applyPredictorDefaults();
                predictorInitialized = true;
            }
            requestAnimationFrame(() => {
                runPredictor();
            });
        }

        function closePredictor() {
            if (!predictorModal) {
                return;
            }
            predictorModal.setAttribute('hidden', '');
            predictorModal.setAttribute('aria-hidden', 'true');
        }

        function applyPredictorDefaults() {
            if (!predictorDefaults) {
                return;
            }
            const mapping = {
                max_edge_ratio: 'predictor-max-edge-ratio',
                plus_toggle: 'predictor-plus-toggle',
                same_shape_limit: 'predictor-same-shape-limit',
                max_pop_out_depth: 'predictor-pop-out-depth',
                mask_validation_time_limit: 'predictor-mask-time',
                max_rectangle_aspect_ratio: 'predictor-rectangle-aspect',
            };
            Object.entries(mapping).forEach(([key, elementId]) => {
                const element = document.getElementById(elementId);
                if (!element) {
                    return;
                }
                const value = predictorDefaults[key];
                if (element.type === 'checkbox') {
                    element.checked = Boolean(value);
                } else if (typeof value === 'number') {
                    element.value = String(value);
                }
                updatePredictorInputOutput(element);
            });
        }

        function updatePredictorInputOutput(element) {
            if (!element) {
                return;
            }
            const outputSelector = element.getAttribute('data-output-id');
            let output = null;
            if (outputSelector) {
                output = document.getElementById(outputSelector);
            }
            if (!output) {
                output = predictorModal ? predictorModal.querySelector(`[data-output-for="${element.id}"]`) : null;
            }
            if (!output) {
                return;
            }
            if (element.type === 'range') {
                const numeric = Number(element.value);
                output.textContent = Number.isFinite(numeric) ? numeric.toFixed(2) : element.value;
            } else {
                output.textContent = element.value;
            }
        }

        function gatherTileSelection() {
            const selection = {};
            tileSelects.forEach((select) => {
                selection[select.id] = Number(select.value) || 0;
            });
            return selection;
        }

        function gatherPredictorOverrides() {
            const overrides = {};
            predictorInputs.forEach((input) => {
                const key = input.getAttribute('data-config-key');
                if (!key) {
                    return;
                }
                if (input.type === 'checkbox') {
                    overrides[key] = input.checked;
                } else {
                    const value = Number(input.value);
                    overrides[key] = Number.isFinite(value) ? value : input.value;
                }
            });
            return overrides;
        }

        function formatKeyLabel(key) {
            return key
                .replace(/_/g, ' ')
                .replace(/\b\w/g, (char) => char.toUpperCase());
        }

        function formatValue(value) {
            if (typeof value === 'boolean') {
                return value ? 'Enabled' : 'Disabled';
            }
            if (typeof value === 'number') {
                const rounded = Math.round(value * 100) / 100;
                return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(2);
            }
            return String(value);
        }

        function formatSecondsDisplay(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric) || numeric <= 0) {
                return 'No limit';
            }
            if (numeric < 60) {
                return `${Math.round(numeric)}s`;
            }
            const minutes = Math.floor(numeric / 60);
            const seconds = Math.round(numeric % 60);
            if (seconds) {
                return `${minutes}m ${seconds}s`;
            }
            return `${minutes}m`;
        }

        function renderPredictorConfig(config) {
            if (!predictorConfigList) {
                return;
            }
            predictorConfigList.innerHTML = '';
            if (!config || typeof config !== 'object') {
                return;
            }
            const entries = Object.entries(config).filter(([key]) => key !== 'phases');
            entries.sort(([a], [b]) => a.localeCompare(b));
            entries.forEach(([key, value]) => {
                const dt = document.createElement('dt');
                dt.textContent = formatKeyLabel(key);
                const dd = document.createElement('dd');
                dd.textContent = formatValue(value);
                predictorConfigList.append(dt, dd);
            });
            const phases = Array.isArray(config.phases) ? config.phases : [];
            if (phases.length) {
                const dt = document.createElement('dt');
                dt.textContent = 'Phases';
                const dd = document.createElement('dd');
                const list = document.createElement('ul');
                list.className = 'predictor-phase-list';
                phases.forEach((phase) => {
                    const item = document.createElement('li');
                    const rotation = _truthy(phase.allow_rotation) ? 'rotation' : 'no rotation';
                    const discards = _truthy(phase.allow_discards) ? 'discards' : 'no discards';
                    const popOuts = _truthy(phase.allow_pop_outs) ? 'pop-outs' : 'no pop-outs';
                    const timeText = formatSecondsDisplay(phase.time_limit_sec);
                    item.textContent = `${phase.name}: ${timeText}, ${rotation}, ${discards}, ${popOuts}`;
                    list.appendChild(item);
                });
                dd.appendChild(list);
                predictorConfigList.append(dt, dd);
            }
        }

        function renderPredictorFactors(factors) {
            if (!predictorFactorsList) {
                return;
            }
            predictorFactorsList.innerHTML = '';
            if (!Array.isArray(factors) || !factors.length) {
                const empty = document.createElement('li');
                empty.className = 'predictor-factor-empty';
                empty.textContent = 'No contributing factors available yet.';
                predictorFactorsList.appendChild(empty);
                return;
            }
            factors
                .slice()
                .sort((a, b) => Math.abs((b && b.contribution) || 0) - Math.abs((a && a.contribution) || 0))
                .slice(0, 6)
                .forEach((factor) => {
                    if (!factor) {
                        return;
                    }
                    const li = document.createElement('li');
                    li.className = 'predictor-factor-item';
                    const header = document.createElement('div');
                    header.className = 'predictor-factor-header';
                    const label = document.createElement('span');
                    label.className = 'predictor-factor-label';
                    label.textContent = factor.label || 'Factor';
                    const value = document.createElement('span');
                    value.className = 'predictor-factor-value';
                    const contribution = Number(factor.contribution);
                    value.textContent = Number.isFinite(contribution)
                        ? `${contribution >= 0 ? '+' : ''}${contribution.toFixed(1)} pts`
                        : '—';
                    header.append(label, value);
                    const description = document.createElement('p');
                    description.className = 'predictor-factor-description';
                    description.textContent = factor.description || '';
                    li.append(header, description);
                    predictorFactorsList.appendChild(li);
                });
        }

        function renderPredictorResult(result) {
            if (!result) {
                return;
            }
            if (predictorScore) {
                const probability = Number(result.probability);
                predictorScore.textContent = Number.isFinite(probability)
                    ? `${probability.toFixed(1)}%`
                    : '--%';
            }
            if (predictorTolerance) {
                const tolerance = Number(result.tolerance);
                predictorTolerance.textContent = Number.isFinite(tolerance)
                    ? `±${tolerance.toFixed(1)}%`
                    : '±--%';
            }
            if (predictorConfidence) {
                predictorConfidence.textContent = `Confidence: ${result.confidence || '—'}`;
            }
            if (predictorSummary) {
                predictorSummary.textContent = result.summary || '';
            }
            renderPredictorFactors(result.factors);
            renderPredictorConfig(result.effective_config);
        }

        function schedulePredictorRun() {
            if (!isPredictorOpen()) {
                return;
            }
            if (predictorRefreshTimeout) {
                clearTimeout(predictorRefreshTimeout);
            }
            predictorRefreshTimeout = setTimeout(() => {
                runPredictor();
            }, 200);
        }

        async function runPredictor() {
            if (!isPredictorOpen()) {
                return;
            }
            if (predictorController) {
                predictorController.abort();
            }
            predictorController = new AbortController();
            setPredictorStatus('Calculating…', 'loading');
            try {
                const response = await fetch(predictorEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tiles: gatherTileSelection(),
                        config: gatherPredictorOverrides(),
                    }),
                    signal: predictorController.signal,
                });
                if (!response.ok) {
                    throw new Error('Unable to calculate prediction.');
                }
                const payload = await response.json();
                renderPredictorResult(payload);
                setPredictorStatus('', 'idle');
            } catch (error) {
                if (error.name === 'AbortError') {
                    return;
                }
                console.error('Predictor error', error);
                setPredictorStatus(error.message || 'Prediction failed.', 'error');
            }
        }

        function _truthy(value) {
            if (typeof value === 'boolean') {
                return value;
            }
            if (typeof value === 'string') {
                return ['1', 'true', 'yes', 'on'].includes(value.trim().toLowerCase());
            }
            if (typeof value === 'number') {
                return value !== 0;
            }
            return false;
        }

        if (predictorOpenButton) {
            predictorOpenButton.addEventListener('click', openPredictor);
        }

        predictorCloseButtons.forEach((button) => {
            button.addEventListener('click', closePredictor);
        });

        if (predictorModal) {
            predictorModal.addEventListener('click', (event) => {
                if (event.target === predictorModal) {
                    closePredictor();
                }
            });
        }

        predictorInputs.forEach((input) => {
            input.addEventListener('input', () => {
                updatePredictorInputOutput(input);
                schedulePredictorRun();
            });
            input.addEventListener('change', () => {
                updatePredictorInputOutput(input);
                schedulePredictorRun();
            });
        });

        tileSelects.forEach((select) => {
            select.addEventListener('change', schedulePredictorRun);
        });

        if (predictorResetButton) {
            predictorResetButton.addEventListener('click', () => {
                applyPredictorDefaults();
                schedulePredictorRun();
            });
        }

        if (predictorRefreshButton) {
            predictorRefreshButton.addEventListener('click', () => {
                runPredictor();
            });
        }

        const overlay = document.getElementById('run-overlay');
        const statusText = document.getElementById('stat-status');
        const phaseText = document.getElementById('stat-phase');
        const phaseAllotmentText = document.getElementById('stat-phase-allotment');
        const attemptText = document.getElementById('stat-attempt');
        const gridText = document.getElementById('stat-grid');
        const elapsedText = document.getElementById('stat-elapsed');
        const totalQuotaText = document.getElementById('stat-total-quota');
        const overallProgressBar = document.getElementById('overall-progress');
        const phaseProgressBar = document.getElementById('phase-progress');
        const overallProgressLabel = document.getElementById('overall-progress-label');
        const phaseProgressLabel = document.getElementById('phase-progress-label');
        const overlaySubtitle = document.getElementById('overlay-subtitle');
        const overlayTitle = document.getElementById('overlay-title');

        let audioContext = null;

        function getAudioContext() {
            if (typeof window === 'undefined') {
                return null;
            }
            const Ctor = window.AudioContext || window.webkitAudioContext;
            if (!Ctor) {
                return null;
            }
            if (!audioContext) {
                audioContext = new Ctor();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(() => {
                    /* ignored */
                });
            }
            return audioContext;
        }

        function scheduleTones(steps) {
            const ctx = getAudioContext();
            if (!ctx || !Array.isArray(steps) || !steps.length) {
                return;
            }
            const base = ctx.currentTime + 0.05;
            steps.forEach((step) => {
                if (!step || typeof step.frequency !== 'number') {
                    return;
                }
                const start = base + Math.max(0, step.offset || 0);
                const duration = Math.max(0.06, step.duration || 0.2);
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                oscillator.type = step.type || 'sine';
                oscillator.frequency.setValueAtTime(step.frequency, start);
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                const volume = Math.max(0.001, step.volume || 0.25);
                const attack = Math.min(0.05, duration * 0.4);
                const release = Math.min(0.1, duration * 0.5);
                const sustainEnd = Math.max(start + attack, start + duration - release);
                gainNode.gain.setValueAtTime(0.0001, start);
                gainNode.gain.exponentialRampToValueAtTime(volume, start + attack);
                gainNode.gain.setValueAtTime(volume, sustainEnd);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, start + duration);
                oscillator.start(start);
                oscillator.stop(start + duration + 0.05);
                if (typeof step.endFrequency === 'number' && step.endFrequency > 0) {
                    oscillator.frequency.exponentialRampToValueAtTime(step.endFrequency, start + duration);
                }
            });
        }

        function playSuccessSound() {
            scheduleTones([
                { frequency: 660, duration: 0.22, volume: 0.22 },
                { frequency: 880, offset: 0.16, duration: 0.28, volume: 0.18 },
                { frequency: 990, offset: 0.32, duration: 0.24, volume: 0.16 },
            ]);
        }

        function playFailureSound() {
            scheduleTones([
                { frequency: 200, duration: 0.32, volume: 0.28, endFrequency: 90, type: 'sine' },
                { frequency: 160, offset: 0.08, duration: 0.26, volume: 0.18, endFrequency: 70, type: 'triangle' },
            ]);
        }

        let currentEventSource = null;
        let currentRunId = null;
        let completionSoundPlayed = false;
        function resetOverlay() {
            statusText.textContent = 'Initializing…';
            phaseText.textContent = '—';
            phaseAllotmentText.textContent = '—';
            attemptText.textContent = '—';
            gridText.textContent = '—';
            totalQuotaText.textContent = '—';
            elapsedText.textContent = '0s';
            updateProgress(overallProgressBar, overallProgressLabel, 0);
            updateProgress(phaseProgressBar, phaseProgressLabel, 0);
            overlaySubtitle.textContent = 'Preparing phases and estimating time requirements.';
            overlayTitle.textContent = 'Running tile solver...';
            overlay.classList.remove('error');
            overlay.setAttribute('aria-hidden', 'false');
            overlay.classList.add('active');
            completionSoundPlayed = false;
        }

        function updateProgress(bar, label, value) {
            if (!bar) {
                return;
            }
            const clamped = Math.max(0, Math.min(100, value));
            bar.style.setProperty('--progress', (clamped / 100).toFixed(4));
            bar.setAttribute('data-progress', clamped.toFixed(1));
            if (label) {
                label.textContent = `${clamped.toFixed(1)}%`;
            }
        }

        function resolveStatusLabel(label) {
            if (typeof label !== 'string') {
                return null;
            }
            const trimmed = label.trim();
            return trimmed.length > 0 ? trimmed : null;
        }

        function setStatusFromVariant(event, fallback = 'Exploring layouts…') {
            const variantLabel = event ? resolveStatusLabel(event.variant_label) : null;
            statusText.textContent = variantLabel || fallback;
        }

        function formatSeconds(seconds) {
            if (!seconds || seconds < 0) {
                return '0s';
            }
            const rounded = Math.round(seconds);
            const minutes = Math.floor(rounded / 60);
            const secs = rounded % 60;
            if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            }
            if (secs > 0) {
                return `${secs}s`;
            }
            return '0s';
        }

        function formatIntegerWithSeparators(value) {
            if (typeof value !== 'number' || !Number.isFinite(value)) {
                return value;
            }
            return value.toLocaleString();
        }

        function buildAttemptDisplay({
            boardLabel,
            attemptIndex,
            totalAttempts,
            timeLimitSec,
            attemptElapsed,
        }) {
            const lines = [];
            const hasAttemptIndex = typeof attemptIndex === 'number' && attemptIndex > 0;
            if (hasAttemptIndex) {
                const attemptCount = typeof totalAttempts === 'number'
                    ? `Attempt ${attemptIndex} of ${totalAttempts}`
                    : `Attempt ${attemptIndex}`;
                lines.push(attemptCount);
            }

            const parsedTimeLimit = Number(timeLimitSec);
            const hasTimeLimit = Number.isFinite(parsedTimeLimit);
            const parsedElapsed = Number(attemptElapsed);
            const hasElapsed = Number.isFinite(parsedElapsed);
            if (hasTimeLimit && hasElapsed) {
                lines.push(`Quota ${formatSeconds(parsedTimeLimit)}`);
            } else if (hasElapsed) {
                lines.push(`Elapsed ${formatSeconds(parsedElapsed)}`);
            } else if (hasTimeLimit) {
                lines.push(`Quota ${formatSeconds(parsedTimeLimit)}`);
            }

            return lines.join('\n');
        }

        function formatBoardSize(size) {
            if (!Array.isArray(size) || size.length < 2) {
                return '—';
            }
            return `${size[0].toFixed(1)} ft × ${size[1].toFixed(1)} ft`;
        }

        function updateGridDisplay({ boardLabel, backtracks }) {
            if (!gridText) {
                return;
            }
            if (!boardLabel || boardLabel === '—') {
                gridText.textContent = '—';
                return;
            }
            const parsedBacktracks = Number(backtracks);
            if (Number.isFinite(parsedBacktracks)) {
                const formattedBacktracks = formatIntegerWithSeparators(parsedBacktracks);
                gridText.innerHTML = `${boardLabel}<br><span class="grid-backtracks">Backtracks ${formattedBacktracks}</span>`;
            } else {
                gridText.textContent = boardLabel;
            }
        }

        function closeEventSource() {
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }
        }

        function handleEvent(data) {
            if (!data) return;
            switch (data.type) {
                case 'run_started':
                    overlaySubtitle.textContent = 'Preparing phases and estimating time requirements.';
                    totalQuotaText.textContent = formatSeconds(data.total_allotment);
                    statusText.textContent = 'Solving…';
                    break;
                case 'phase_started':
                    statusText.textContent = `Solving ${data.phase}`;
                    phaseText.textContent = `${data.phase} (${(data.phase_index + 1)} of ${data.phase_count})`;
                    phaseAllotmentText.textContent = data.time_limit_sec
                        ? `${formatSeconds(data.time_limit_sec)}`
                        : 'No limit';
                    attemptText.textContent = '—';
                    gridText.textContent = '—';
                    updateProgress(phaseProgressBar, phaseProgressLabel, 0);
                    break;
                case 'attempt_started':
                    const boardLabel = formatBoardSize(data.board_size_ft);
                    updateGridDisplay({
                        boardLabel,
                        backtracks: data.backtracks,
                    });
                    attemptText.textContent = buildAttemptDisplay({
                        boardLabel,
                        attemptIndex: data.attempt_index,
                        totalAttempts: data.total_attempts,
                        timeLimitSec: data.time_limit_sec,
                        attemptElapsed: data.attempt_elapsed,
                    });
                    setStatusFromVariant(data);
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    updateProgress(phaseProgressBar, phaseProgressLabel, (data.phase_progress || 0) * 100);
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    break;
                case 'attempt_completed':
                    if (Array.isArray(data.board_size_ft)) {
                        const boardLabelCompleted = formatBoardSize(data.board_size_ft);
                        updateGridDisplay({
                            boardLabel: boardLabelCompleted,
                            backtracks: data.backtracks,
                        });
                        attemptText.textContent = buildAttemptDisplay({
                            boardLabel: boardLabelCompleted,
                            attemptIndex: data.attempt_index,
                            totalAttempts: data.total_attempts,
                            timeLimitSec: data.time_limit_sec,
                            attemptElapsed: data.attempt_elapsed,
                        });
                    }
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    updateProgress(phaseProgressBar, phaseProgressLabel, (data.phase_progress || 0) * 100);
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    if (data.success) {
                        statusText.textContent = 'Layout found!';
                    } else {
                        setStatusFromVariant(data);
                    }
                    break;
                case 'attempt_progress':
                    setStatusFromVariant(data);
                    if (Array.isArray(data.board_size_ft)) {
                        const boardLabel = formatBoardSize(data.board_size_ft);
                        updateGridDisplay({
                            boardLabel,
                            backtracks: data.backtracks,
                        });
                        attemptText.textContent = buildAttemptDisplay({
                            boardLabel,
                            attemptIndex: data.attempt_index,
                            totalAttempts: data.total_attempts,
                            timeLimitSec: data.time_limit_sec,
                            attemptElapsed: data.attempt_elapsed,
                        });
                    }
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    updateProgress(phaseProgressBar, phaseProgressLabel, (data.phase_progress || 0) * 100);
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    break;
                case 'phase_completed':
                    statusText.textContent = data.success ? `${data.phase} complete` : `${data.phase} exhausted`;
                    updateProgress(phaseProgressBar, phaseProgressLabel, 100);
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    break;
                case 'run_completed':
                    overlaySubtitle.textContent = data.success
                        ? 'Solver finished. Preparing results…'
                        : 'No solution found within the time quota.';
                    statusText.textContent = data.success ? 'Solver finished' : 'Solver complete (no solution)';
                    if (data.overall_progress != null) {
                        updateProgress(overallProgressBar, overallProgressLabel, (data.overall_progress || 0) * 100);
                    }
                    elapsedText.textContent = formatSeconds(data.overall_elapsed);
                    if (!completionSoundPlayed) {
                        if (data.success) {
                            playSuccessSound();
                        } else {
                            playFailureSound();
                        }
                        completionSoundPlayed = true;
                    }
                    break;
                case 'error':
                    statusText.textContent = 'Unable to start solver';
                    overlaySubtitle.textContent = data.message || 'An unexpected error occurred.';
                    updateProgress(overallProgressBar, overallProgressLabel, 0);
                    updateProgress(phaseProgressBar, phaseProgressLabel, 0);
                    if (!completionSoundPlayed) {
                        playFailureSound();
                        completionSoundPlayed = true;
                    }
                    break;
                case 'finished':
                    closeEventSource();
                    if (data.success) {
                        if (!completionSoundPlayed) {
                            playSuccessSound();
                            completionSoundPlayed = true;
                        }
                        window.location.href = `/runs/${data.run_id}/result`;
                    } else if (data.error) {
                        overlay.classList.add('error');
                        overlayTitle.textContent = 'Solver error';
                        overlaySubtitle.textContent = data.error;
                        overlay.setAttribute('aria-hidden', 'false');
                        if (!completionSoundPlayed) {
                            playFailureSound();
                            completionSoundPlayed = true;
                        }
                    } else {
                        if (!completionSoundPlayed) {
                            playFailureSound();
                            completionSoundPlayed = true;
                        }
                        window.location.href = `/runs/${data.run_id}/result`;
                    }
                    break;
                default:
                    break;
            }
        }

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            resetOverlay();
            closeEventSource();
            currentRunId = null;
            const formData = new FormData(form);
            try {
                const response = await fetch('{{ url_for('start_run') }}', {
                    method: 'POST',
                    body: formData,
                });
                if (!response.ok) {
                    throw new Error('Unable to start solver run.');
                }
                const payload = await response.json();
                currentRunId = payload.run_id;
                currentEventSource = new EventSource(`/runs/${currentRunId}/stream`);
                currentEventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleEvent(data);
                    } catch (err) {
                        console.error('Failed to parse progress event', err);
                    }
                };
                currentEventSource.addEventListener('end', () => {
                    closeEventSource();
                });
            } catch (error) {
                console.error(error);
                statusText.textContent = 'Unable to start solver';
                overlaySubtitle.textContent = error.message || 'An unexpected error occurred.';
                overlay.classList.add('error');
            }
        });
    </script>
</body>
</html>